/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Text Convert
 #	author : miyako
 #	2015/02/13
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

ARRAY_LONGINT   CP_CODES;
ARRAY_TEXT      CP_NAMES;

ARRAY_TEXT      ICU_NAMES;
ARRAY_TEXT      ICONV_NAMES;

static int print_one (unsigned int namescount, const char * const * names, void* data)
{    
    ARRAY_TEXT *encodings = (ARRAY_TEXT *)data;
    
    for (unsigned int i = 0; i < namescount; ++i) 
    {
        PA_YieldAbsolute();
        CUTF8String name = CUTF8String((const uint8_t *)names[i]);
        encodings->appendUTF8String(&name);
    }
    
    return 0;
}

void InitPlugin(){
    
    ICONV_NAMES.setSize(1);
    
    iconvlist(print_one, &ICONV_NAMES);
    
    ICU_NAMES.setSize(1);
    
   int32_t count = ucnv_countAvailable();

    C_TEXT n;

    for(int32_t i = 0; i < count; ++i)
    {
        PA_YieldAbsolute();
        CUTF8String name = CUTF8String((const uint8_t *)ucnv_getAvailableName(i));
        n.setUTF8String(&name);
        ICU_NAMES.appendUTF16String((const PA_Unichar *)n.getUTF16StringPtr());
    }

    CP_CODES.setSize(1);		
    CP_NAMES.setSize(1);	
    
#if VERSIONWIN
    IMultiLanguage2* mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&mlang);
    //not support on windows xp; who cares... 
    if(mlang)
    {
        ULONG i, count, celt = 32;//	number of codes page information to retrive at a time
        unsigned int index = 1;
        MIMECPINFO infos[32];
        IEnumCodePage* codepages = NULL;
        mlang->EnumCodePages(MIMECONTF_VALID, 0, &codepages);
        if(codepages)
        {
            
            while(codepages->Next(celt, infos, &count) == S_OK)
            {
                PA_YieldAbsolute();
                
                for(i = 0; i < count ; i++)
                {
                    index++;
                    CP_CODES.appendIntValue(infos[i].uiCodePage);
                    CP_NAMES.appendUTF16String((const PA_Unichar *)infos[i].wszWebCharset, wcslen(infos[i].wszWebCharset));
                }			
            }
            
            codepages->Release();
        }
        mlang->Release();
    }
#else
    
    UInt32 i = 0, number = 0;
    NSString *name;
    
    const CFStringEncoding *encodings = CFStringGetListOfAvailableEncodings();
    
    while (encodings[i] != kCFStringEncodingInvalidId){  
        
        PA_YieldAbsolute();
        
        name = (NSString *)CFStringConvertEncodingToIANACharSetName(encodings[i]);  
        
        if(name){
            //calling augumented function
            number = _CFStringConvertEncodingToWindowsCodepage(encodings[i]);
            
            /*
             if(number == -1){
             NSLog(@"encoding with negative code page %@\n", name);
             }
             
             if(number == 0){
             NSLog(@"charset name with no corresponding code page %@\n", name);
             }
             */
            
            if(number > 0){
                CP_CODES.appendIntValue(number);
                CP_NAMES.appendUTF16String(name);
            }
            
        }
        i++;
    }
    
#endif
    
}

#pragma mark -
    
void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :            
            InitPlugin();
            break;            
// --- ICU

		case 1 :
			ICU_GET_ENCODING_LIST(pResult, pParams);
			break;

		case 2 :
			ICU_Get_good_encodings(pResult, pParams);
			break;

		case 3 :
			ICU_Get_best_encoding(pResult, pParams);
			break;

		case 4 :
			ICU_Normalize_text(pResult, pParams);
			break;

		case 5 :
			ICU_Transform_text(pResult, pParams);
			break;

		case 6 :
			ICU_Get_error_text(pResult, pParams);
			break;

		case 7 :
			ICU_Convert_to_text(pResult, pParams);
			break;

		case 8 :
			ICU_Convert_from_text(pResult, pParams);
			break;

// --- ICONV

		case 9 :
			ICONV_Convert(pResult, pParams);
			break;

// --- JIS

		case 10 :
			JIS_Convert_to_text(pResult, pParams);
			break;

		case 11 :
			JIS_Convert_from_text(pResult, pParams);
			break;

// --- ICONV

		case 12 :
			ICONV_GET_ENCODING_LIST(pResult, pParams);
			break;

// --- CP

		case 13 :
			CP_GET_ENCODING_LIST(pResult, pParams);
			break;

		case 14 :
			CP_Get_best_encoding(pResult, pParams);
			break;

		case 15 :
			CP_Convert_from_text(pResult, pParams);
			break;

		case 16 :
			CP_Convert_to_text(pResult, pParams);
			break;

		case 17 :
			CP_Get_good_encodings(pResult, pParams);
			break;

	}
}

#pragma mark -

// -------------------------------------- ICU -------------------------------------

void ICU_GET_ENCODING_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
    ICU_NAMES.toParamAtIndex(pParams, 1);
}

void ICU_Get_good_encodings(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_BLOB sourceData;
    ARRAY_TEXT names;
    ARRAY_TEXT languages;
    ARRAY_LONGINT confidences;
    C_LONGINT returnValue;
    C_TEXT name;
    C_TEXT language;
    
    sourceData.fromParamAtIndex(pParams, 1);
    names.setSize(1);
    languages.setSize(1);
    confidences.setSize(1);
    
    UErrorCode error = U_ZERO_ERROR;
    
    UCharsetDetector *detector = ucsdet_open(&error);
    
    if(!error){
        
        ucsdet_setText(detector, (const char *)sourceData.getBytesPtr(),
                       sourceData.getBytesLength(),
                       &error);
        
        if(!error){
            
            int32_t i, count;
            
            const UCharsetMatch **matches = ucsdet_detectAll(detector, &count, &error);	
            
            if(!error){    
                
                for(i = 0; i < count; ++i){
                    
                    PA_YieldAbsolute();
                    
                    CUTF8String n = CUTF8String((const uint8_t *)ucsdet_getName(matches[i], &error));
                    CUTF8String l = CUTF8String((const uint8_t *)ucsdet_getLanguage(matches[i], &error));					
                    name.setUTF8String(&n);
                    language.setUTF8String(&l);	
                    names.appendUTF16String((const PA_Unichar *)name.getUTF16StringPtr());
                    languages.appendUTF16String((const PA_Unichar *)language.getUTF16StringPtr());					
                    confidences.appendIntValue(ucsdet_getConfidence(matches[i], &error));
                    
                }
                                
            }else{
                returnValue.setIntValue(error);			
            }		
        }else{
            returnValue.setIntValue(error);			
        }
        
        ucsdet_close(detector);
        
    }else{
        returnValue.setIntValue(error);		
    }
    
    names.toParamAtIndex(pParams, 2);
    languages.toParamAtIndex(pParams, 3);
    confidences.toParamAtIndex(pParams, 4);
    returnValue.setReturn(pResult);
}

void ICU_Get_best_encoding(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_BLOB sourceData;
    C_TEXT name;
    C_TEXT language;
    C_LONGINT confidence;
    C_LONGINT returnValue;
    
    sourceData.fromParamAtIndex(pParams, 1);
    
    UErrorCode error = U_ZERO_ERROR;
    
    UCharsetDetector *detector = ucsdet_open(&error);
    
    if(!error){
        
        ucsdet_setText(detector, (const char *)sourceData.getBytesPtr(),
                       sourceData.getBytesLength(),
                       &error);
        
        if(!error){
            
            const UCharsetMatch *match = ucsdet_detect(detector, &error);	
            
            if(!error){
                
                CUTF8String n = CUTF8String((const uint8_t *)ucsdet_getName(match, &error));
                CUTF8String l = CUTF8String((const uint8_t *)ucsdet_getLanguage(match, &error));
                
                name.setUTF8String(&n);
                language.setUTF8String(&l);
                confidence.setIntValue(ucsdet_getConfidence(match, &error));
                
            }else{
                returnValue.setIntValue(error);			
            }		
        }else{
            returnValue.setIntValue(error);			
        }
        
        ucsdet_close(detector);
        
    }else{
        returnValue.setIntValue(error);		
    }
    
    name.toParamAtIndex(pParams, 2);
    language.toParamAtIndex(pParams, 3);
    confidence.toParamAtIndex(pParams, 4);
    returnValue.setReturn(pResult);
}

void ICU_Normalize_text(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT sourceText;
    C_LONGINT normalizationForm;
    C_TEXT targetText;
    C_LONGINT returnValue;
    
    sourceText.fromParamAtIndex(pParams, 1);
    normalizationForm.fromParamAtIndex(pParams, 2);
    
    UErrorCode error = U_ZERO_ERROR;
    
    const char *name;
    UNormalization2Mode mode;
    
    switch ((NormalizationForm)normalizationForm.getIntValue()) 
    {
        case _NFC:
            name = "nfc";
            mode = UNORM2_COMPOSE;
            break;
        case _NFD:
            name = "nfc";
            mode = UNORM2_DECOMPOSE;
            break;	
        case _NFKC:
            name = "nfkc";
            mode = UNORM2_COMPOSE;
            break;
        case _NFKD:
            name = "nfkc";
            mode = UNORM2_DECOMPOSE;
            break;			
        default:
            name = "nfkc_cf";
            mode = UNORM2_COMPOSE;			
            break;
    }
    
    const UNormalizer2 *normalizer = unorm2_getInstance(NULL, name, mode, &error);
    
    if(!error)
    {
        int32_t sourceLength = sourceText.getUTF16Length();
        const UChar *source = (UChar *)sourceText.getUTF16StringPtr(); 
        
        int32_t textCapacity = sourceLength + 1;	
        std::vector<UChar> text(textCapacity);
        
        int32_t size = unorm2_normalize(normalizer,
                                        source,
                                        sourceLength,
                                        (UChar *)&text[0],
                                        textCapacity,
                                        &error);
        
        if(size >= textCapacity)
        {
            error = U_ZERO_ERROR;
            
            textCapacity = size + 1;			
            text.resize(textCapacity);
            
            size = unorm2_normalize(normalizer,
                                    source,
                                    sourceLength,
                                    (UChar *)&text[0],
                                    textCapacity,
                                    &error);
            
        }
        
        if(!error)
        {	
            targetText.setUTF16String((const PA_Unichar*)&text[0], size);
        }else{
            returnValue.setIntValue(error);		
        }		
        
    }else{
        returnValue.setIntValue(error);			
    }
    
    targetText.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

void ICU_Transform_text(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT tId;
    C_TEXT tRules;
    C_LONGINT tDirection;
    C_TEXT sourceText;
    C_TEXT targetText;	
    C_LONGINT returnValue;
    
    tId.fromParamAtIndex(pParams, 1);
    tRules.fromParamAtIndex(pParams, 2);
    tDirection.fromParamAtIndex(pParams, 3);
    sourceText.fromParamAtIndex(pParams, 4);
    
    UErrorCode error = U_ZERO_ERROR;
    
    const UChar *transId = (UChar *)tId.getUTF16StringPtr();
    int32_t idLength = tId.getUTF16Length();
    
    const UChar *transRules = NULL;
    int32_t rulesLength = tRules.getUTF16Length();
    
    if(rulesLength)
        transRules = (UChar *)tRules.getUTF16StringPtr();
    
    UTransDirection direction = (UTransDirection)tDirection.getIntValue();
    
    UTransliterator *transliterator = utrans_openU(transId,
                                                   idLength,
                                                   direction,
                                                   transRules,
                                                   rulesLength,
                                                   NULL,
                                                   &error);
    
    if (!error)
    {
        int32_t textLength = sourceText.getUTF16Length();
        int32_t textCapacity = textLength + 1;
        int32_t limit = textLength;
        
        std::vector<UChar> text(textCapacity);	
        
        memcpy(&text[0], (const void *)sourceText.getUTF16StringPtr(), (sourceText.getUTF16Length())*sizeof(PA_Unichar)); 
        
        utrans_transUChars(transliterator,
                           (UChar *)&text[0],
                           &textLength,
                           textCapacity,
                           0,
                           &limit,
                           &error
                           );
        
        if(textLength >= textCapacity)
        {
            //the original text is lost sometimes?
            memcpy(&text[0], (const void *)sourceText.getUTF16StringPtr(), (sourceText.getUTF16Length())*sizeof(PA_Unichar)); 
            
            textCapacity = textLength + 1;
            text.resize(textCapacity);
            textLength = sourceText.getUTF16Length();
            limit = textLength;
            error = U_ZERO_ERROR;//need to reset error 
            
            utrans_transUChars(transliterator,
                               (UChar *)&text[0],
                               &textLength,
                               textCapacity,
                               0,
                               &limit,
                               &error
                               );			
            
        }
        
        if(!error)
        {	
            targetText.setUTF16String((const PA_Unichar*)&text[0], textLength);
        }else{
            returnValue.setIntValue(error);		
        }
        
        utrans_close(transliterator);
        
    }else{
        returnValue.setIntValue(error);		
    }	
    
    targetText.toParamAtIndex(pParams, 5);
    returnValue.setReturn(pResult);
}

void ICU_Get_error_text(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_LONGINT errorCode;
    C_TEXT returnValue;
    
    errorCode.fromParamAtIndex(pParams, 1);
    
    CUTF8String errorString = CUTF8String((const uint8_t *)u_errorName((UErrorCode)errorCode.getIntValue()));
    returnValue.setUTF8String(&errorString);
    
    returnValue.setReturn(pResult);
}

void ICU_Convert_to_text(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_BLOB sourceData;
    C_TEXT encodingName;
    C_TEXT targetText;
    C_LONGINT returnValue;
    
    sourceData.fromParamAtIndex(pParams, 1);
    encodingName.fromParamAtIndex(pParams, 2);
    
    UErrorCode error = U_ZERO_ERROR;
    
    CUTF8String sourceEncoding;		
    encodingName.copyUTF8String(&sourceEncoding);	
    
    UConverter *converter = ucnv_open((const char *)sourceEncoding.c_str(), &error);
    
    if (!error) 
    {
        int32_t sourceLength = sourceData.getBytesLength();
        int32_t targetLength = (sourceLength / ucnv_getMinCharSize(converter)) + 1;
        
        std::vector<UChar> buf(targetLength);
        
        UChar *target = (UChar *)&buf[0];	
        const char *source = (char *)sourceData.getBytesPtr(); 
        
        int32_t len = ucnv_toUChars(converter, target, targetLength, source, sourceLength, &error);
        
        if(!error)
        { 
            targetText.setUTF16String((const PA_Unichar*)&buf[0], len);
        }else{
            returnValue.setIntValue(error);		
        }
        
        ucnv_close(converter);
        
    }else{
        returnValue.setIntValue(error);
    }
    
    targetText.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

void ICU_Convert_from_text(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT sourceText;
    C_TEXT encodingName;
    C_BLOB targetData;
    C_LONGINT returnValue;
    
    sourceText.fromParamAtIndex(pParams, 1);
    encodingName.fromParamAtIndex(pParams, 2);
    
    UErrorCode error = U_ZERO_ERROR;
    
    CUTF8String targetEncoding;		
    encodingName.copyUTF8String(&targetEncoding);	
    
    UConverter *converter = ucnv_open((const char *)targetEncoding.c_str(), &error);	
    
    if(!error)
    {
        int32_t  sourceLength = sourceText.getUTF16Length();
        int32_t  targetLength = ((sourceLength + 1) * ucnv_getMaxCharSize(converter));
        
        std::vector<uint8_t> buf(targetLength);
        
        char *target = (char *)&buf[0];			
        const UChar *source = (UChar *)sourceText.getUTF16StringPtr(); 
        
        int32_t len = ucnv_fromUChars(converter, target, targetLength, source, sourceLength, &error);
        
        switch (error) 
        {
            case U_ZERO_ERROR:
                targetData.setBytes((const uint8_t *)&buf[0], len);
                break;
            case U_STRING_NOT_TERMINATED_WARNING:
                targetData.setBytes((const uint8_t *)&buf[0], len);
                break;				
            default:
                returnValue.setIntValue(error);	
                break;
        }
        
        ucnv_close(converter);		
        
    }else{
        returnValue.setIntValue(error);	
    }
    
    targetData.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

// -------------------------------------- JIS -------------------------------------

#pragma mark -

/*
 there are 3 unofficial ways to encode half width katakana in iso-2022-jp;
 shift out/shift in
 0x0E to start h/w katakana, 0x0F to terminate
 escape sequence
 0x1B 0x28 0x49 to switch on h/w/ katakana
 jis8
 use 8 byte codes (0xA1 - 0xDF) for katakana
 */

void JIS_TO_ISO(C_BLOB *data, int type)
{
    std::string str;
    size_t pos = 0;
    size_t found = 0;
    size_t i = 0;
    std::string result;
    std::string escape;
    
    switch (type) 
    {
        case JIS7_SO_SI:
            str = std::string((const char *)data->getBytesPtr(), (size_t)data->getBytesLength());
            
            for(pos = str.find("\x0E"); pos != std::string::npos; pos = str.find("\x0E", found))
            {
                PA_YieldAbsolute();
                result.append(str.substr(found, pos-found));				
                result.append("\x1B\x28\x49");		
                found = pos + 1;
                
                pos = str.find("\x0F", found);
                
                if(pos != std::string::npos)
                {	
                    result.append(str.substr(found, pos-found));	
                    found = pos + 1;					
                }
            }
            
            result.append(str.substr(found, str.length()-found));
            data->setBytes((const uint8_t *)result.c_str(), result.length());	   
            break;
            
        case JIS8:
            str = std::string((const char *)data->getBytesPtr(), (size_t)data->getBytesLength());
            
            for(pos = str.find("\x1B\x28\x4A"); pos != std::string::npos; pos = str.find("\x1B\x28\x4A", found))
            {
                PA_YieldAbsolute();
                result.append(str.substr(found, pos-found));				
                result.append("\x1B\x28\x49");
                found = pos + 3;
                
                pos = str.find("\x1B", found);
                
                if(pos != std::string::npos)
                {	
                    for(i = found;i < pos; i++){
                        unsigned char kana = str.at(i);
                        result.append(1, kana - 0x80);
                    }
                    found = pos;
                }
            }			
            
            result.append(str.substr(found, str.length()-found));
            data->setBytes((const uint8_t *)result.c_str(), result.length());
            break;	
            
        default:
            break;
    }	
}

void ISO_TO_JIS(C_BLOB *data, int type)
{
    std::string str;
    size_t pos = 0;
    size_t found = 0;
    size_t i = 0;
    std::string result;
    
    switch (type) 
    {
        case JIS7_SO_SI:
            str = std::string((const char *)data->getBytesPtr(), (size_t)data->getBytesLength());
            
            for(pos = str.find("\x1B\x28\x49"); pos != std::string::npos; pos = str.find("\x1B\x28\x49", found))
            {
                PA_YieldAbsolute();
                result.append(str.substr(found, pos-found));				
                result.append("\x0E");		
                found = pos + 3;
                
                pos = str.find("\x1B", found);
                
                if(pos != std::string::npos)
                {	
                    result.append(str.substr(found, pos-found));
                    result.append("\x0F");
                    result.append(str.substr(found+1, 3));
                    found = pos + 3;					
                }else
                {
                    result.append("\x0F");
                }
            }
            
            result.append(str.substr(found, str.length()-found));
            data->setBytes((const uint8_t *)result.c_str(), result.length());	   
            break;
            
        case JIS8:
            str = std::string((const char *)data->getBytesPtr(), (size_t)data->getBytesLength());
            
            for(pos = str.find("\x1B\x28\x49"); pos != std::string::npos; pos = str.find("\x1B\x28\x49", found))
            {
                PA_YieldAbsolute();
                result.append(str.substr(found, pos-found));
                result.append("\x1B\x28\x4A");
                found = pos + 3;
                
                pos = str.find("\x1B", found);
                
                if(pos != std::string::npos)
                {	
                    for(i = found;i < pos; i++)
                    {
                        unsigned char kana = str.at(i);
                        result.append(1, kana + 0x80);
                    }
                    found = pos;
                }
                
            }
            
            result.append(str.substr(found, str.length()-found));
            data->setBytes((const uint8_t *)result.c_str(), result.length());
            break;	
            
        default:
            break;
    }	
}

void JIS_Convert_to_text(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    JIS_TO_ISO(&Param1, Param2.getIntValue());
    
#if VERSIONMAC	
    
    NSString *str = [[NSString alloc]initWithBytes:(const void *)Param1.getBytesPtr() length:(unsigned int)Param1.getBytesLength() encoding:NSISO2022JPStringEncoding];		
    
    if(str)
    {
        returnValue.setUTF16String(str);
        [str release];
    }
    
#else
    
    unsigned int len, mlen, ulen;
    DWORD mode = 0;
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
        mlen = Param1.getBytesLength();
        if(!mlang->ConvertStringToUnicode(&mode, 50221, (LPSTR)Param1.getBytesPtr(), (UINT *)&mlen, NULL, (UINT *)&ulen))
        {
            len = ((ulen * sizeof(PA_Unichar)) + sizeof(PA_Unichar));
            std::vector<uint8_t> buf(len);
            mlang->ConvertStringToUnicode(&mode, 50221, (LPSTR)Param1.getBytesPtr(), (UINT *)&mlen, (WCHAR *)&buf[0], (UINT*)&ulen);
            returnValue.setUTF16String((const PA_Unichar *)&buf[0], (uint32_t)ulen);	
        }
        mlang->Release();
    }
#endif

	returnValue.setReturn(pResult);
}

void JIS_Convert_from_text(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_BLOB returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

#if VERSIONMAC	
    
    NSMutableString *str = [[NSMutableString alloc]initWithCharacters:Param1.getUTF16StringPtr() length:Param1.getUTF16Length()];
    
    if(str)
    {
        NSData *data = [str dataUsingEncoding:NSISO2022JPStringEncoding allowLossyConversion:NO];	
        returnValue.setBytes((const uint8_t *)[data bytes], (uint32_t)[data length]);
        ISO_TO_JIS(&returnValue, Param2.getIntValue());
        returnValue.setReturn(pResult);
        [str release];
    }
    
#else
    
    unsigned int len, mlen, ulen;
    DWORD mode = 0;
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
        ulen = (unsigned int)Param1.getUTF16Length();		
        
        if(!mlang->ConvertStringFromUnicode(&mode, 50221, (LPWSTR)Param1.getUTF16StringPtr(), (UINT *)&ulen, NULL, (UINT *)&mlen))
        {
            len = mlen+1;
            std::vector<uint8_t> buf(len);
            mlang->ConvertStringFromUnicode(&mode, 50221, (LPWSTR)Param1.getUTF16StringPtr(), (UINT *)&ulen, (CHAR *)&buf[0], (UINT *)&mlen);			
            returnValue.setBytes((const uint8_t *)&buf[0], (uint32_t)mlen);
            ISO_TO_JIS(&returnValue, Param2.getIntValue());
            returnValue.setReturn(pResult);
        }
        mlang->Release();
    }
    
#endif

	returnValue.setReturn(pResult);
}

// ------------------------------------- ICONV ------------------------------------

#pragma mark -

void ICONV_Convert(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_BLOB Param3;
    C_BLOB Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CUTF8String _io;
    CUTF8String _eo;	
    
    Param1.copyUTF8String(&_io);
    Param2.copyUTF8String(&_eo);
    
    const char *inEncoding = (const char *)_io.c_str();
    const char *outEncoding = (const char *)_eo.c_str();
    
    iconv_t conv_desc = iconv_open (outEncoding, inEncoding);
    
    if ((size_t)conv_desc == (size_t) -1)
    {
        returnValue.setIntValue(errno);	
    }else{
        
        char *inData = (char *)Param3.getBytesPtr();		
        size_t inDataLen = (size_t)Param3.getBytesLength();
        size_t outDataLen = (size_t)(inDataLen * 4) + 4;	
        size_t outDataSize = outDataLen;
        
        char *outData = (char *)calloc(outDataLen, 1);
        char *outDataPtr = outData;
        
        size_t iconv_value;
                
        iconv_value = iconv (conv_desc, &inData, &inDataLen, &outData, &outDataLen);
        
        if (iconv_value)
        {
            returnValue.setIntValue(errno);
        }else{
            Param4.setBytes((const uint8_t *)outDataPtr, outDataSize-outDataLen);
        }
        free(outDataPtr);		
        iconv_close (conv_desc);
    }
    
    Param4.toParamAtIndex(pParams, 4);
    returnValue.setReturn(pResult);
}

void ICONV_GET_ENCODING_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ICONV_NAMES.toParamAtIndex(pParams, 1);
}

// -------------------------------------- CP --------------------------------------

#pragma mark -

void CP_GET_ENCODING_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
    CP_CODES.toParamAtIndex(pParams, 1);
    CP_NAMES.toParamAtIndex(pParams, 2);
}

void CP_Get_best_encoding(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    char *data = (char *)Param1.getBytesPtr();
    size_t size = Param1.getBytesLength();
    
#if VERSIONWIN
    
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
        int scores = CP_CODES.getSize();
        std::vector<DetectEncodingInfo> encodings(scores);
        mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, data, (INT *)&size, &encodings[0], &scores);
        
        //no HRESULT?
        INT confidence = 0;
        for(int i = 0; i < scores ; ++i)
        {
            if(encodings[i].nLangID != 0)
            {
                if(confidence < encodings[i].nConfidence){
                    Param2.setIntValue(encodings[i].nCodePage);
                }
            }
        }                 

        mlang->Release();
    }
#else
    
    ItemCount count, num;
    
    if(!TECCountAvailableTextEncodings(&count))
    {
        std::vector<TextEncoding> _encodings(count);
        TextEncoding *encodings = &_encodings[0];
        
        TECGetAvailableTextEncodings(encodings, count, &num);
        
        int len = MAX_LENGTH_FOR_ENCODING_NAME;
        
        TECSnifferObjectRef sniffer;
        
        if(!TECCreateSniffer(&sniffer, encodings, num))
        {
            ItemCount numTextEncodings = num;
            ItemCount maxErrs = size;
            ItemCount maxFeatures = size;
            
            std::vector<ItemCount> _numErrsArray(count);
            ItemCount *numErrsArray = &_numErrsArray[0];
            
            std::vector<ItemCount> _numFeaturesArray(count);
            ItemCount *numFeaturesArray = &_numFeaturesArray[0];
            
            OSStatus status = TECSniffTextEncoding(sniffer, 
                                                   (ConstTextPtr)data, 
                                                   (ByteCount)size, 
                                                   encodings, 
                                                   numTextEncodings,  
                                                   numErrsArray, 
                                                   maxErrs, 
                                                   numFeaturesArray,
                                                   maxFeatures);
            
            if(status){
                returnValue.setIntValue(ERR_DETECTION_FAILED); 
            }else{
                
                RegionCode actualRegion;
                TextEncoding actualEncoding;
                ByteCount length;
                
                TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault, 
                                                          kTextEncodingDefaultVariant, 
                                                          kUnicode16BitFormat);
                
                std::vector<char> buf(len);
                
                if(!GetTextEncodingName(
                                        encodings[0], 
                                        kTextEncodingFullName, 
                                        0, 
                                        unicode, 
                                        len, 
                                        &length, 
                                        &actualRegion, 
                                        &actualEncoding, 
                                        (TextPtr)&buf[0]))
                {
                    CFStringRef name = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar*)&buf[0], (length/2));
                    if(name)
                    {
                        UInt32 codepage = TextEncodingNameToWindowsCodepage(name);
                        if(codepage > 0){
                            Param2.setIntValue(codepage);
                        }
                        CFRelease(name);								
                    }
                    
                }
                
            }
            
        }
        
    }	
    
#endif	    

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void CP_Convert_from_text(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

#if VERSIONMAC	
    
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(Param3.getIntValue());	
    
    if((encoding == kCFStringEncodingInvalidId) || !CFStringIsEncodingAvailable(encoding))
    {
        
        returnValue.setIntValue(ERR_INVALID_ENCODING);    
        
    }else{
        
        NSString *str = Param1.copyUTF16String();
        uint32_t size = CFStringGetMaximumSizeForEncoding([str length], encoding) + sizeof(PA_Unichar);	//2 bytes for null termination	
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), encoding, '?', false, (UInt8 *)&buf[0], size, &len);
        Param2.setBytes((const uint8_t *)&buf[0], len);	
        [str release];			   
    }
    
#else
    
    LPWSTR ustr;
    DWORD codepage = Param3.getIntValue();
    UINT len, mlen, ulen;
    DWORD mode = 0;    
    
    ustr = (LPWSTR)Param1.getUTF16StringPtr();	 
    ulen = (unsigned int)Param1.getUTF16Length();
    
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
        mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, NULL, &mlen);
        len = mlen+2;
        std::vector<uint8_t> buf(len);
        HRESULT result = mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, (CHAR *)&buf[0], &mlen);
        
        switch(result){
            case E_FAIL:
                returnValue.setIntValue(ERR_CONVERSION_FAILED); 
                break;
            case S_FALSE:
                returnValue.setIntValue(ERR_INVALID_ENCODING); 
                break;            
            case S_OK:
                Param2.setBytes(&buf[0], mlen);
                break;        
        } 
        
        mlang->Release();
    }
    
#endif	
    
    Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void CP_Convert_to_text(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);

#if VERSIONMAC
    
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(Param3.getIntValue());	
    
    if((encoding == kCFStringEncodingInvalidId) || !CFStringIsEncodingAvailable(encoding))
    {
        
        returnValue.setIntValue(ERR_INVALID_ENCODING);    
        
    }else{
        
        NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault, 
                                                            Param1.getBytesPtr(), 
                                                            Param1.getBytesLength(), 
                                                            encoding, 
                                                            true);
        if(str)
        {
            uint32_t size = ([str length] * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
            std::vector<uint8_t> buf(size);
            if([str getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
            {
                Param2.setUTF16String((const PA_Unichar *)&buf[0], [str length]);
            }else
            {
                returnValue.setIntValue(ERR_CONVERSION_FAILED);     
            }
            [str release];
        }
        
        else{
            //try older API
            TextEncoding textEncoding = TECConvertWindowsCodepageToTextEncoding(Param3.getIntValue());
            OptionBits flags = kUnicodeForceASCIIRangeMask|kUnicodeStringUnterminatedMask;
            UnicodeMapping mapping;
            mapping.otherEncoding = textEncoding;
            mapping.unicodeEncoding = kTextEncodingUnicodeDefault;
            mapping.mappingVersion = kUnicodeUseLatestMapping;
            TextToUnicodeInfo info;
            CreateTextToUnicodeInfoByEncoding(textEncoding,&info);
            ByteCount sourceLen = Param1.getBytesLength();
            ConstLogicalAddress source = Param1.getBytesPtr();
            ByteCount lengthRead = 0;
            ByteCount lengthReturned = 0;
            
            unsigned int size = ((sourceLen * 4) + 1);
            std::vector<uint8_t> buf(size);
            
            if(info)
            {	
                ConvertFromTextToUnicode(info, 
                                         sourceLen, 
                                         source, 
                                         flags, 
                                         0, 
                                         NULL, 
                                         NULL, 
                                         NULL, 
                                         size, 
                                         &lengthRead, 
                                         &lengthReturned, 
                                         (UniChar *)&buf[0]);
            }
            
            else{
                //try even older API
                TECObjectRef converter;	
                TECCreateConverter(&converter, textEncoding, kTextEncodingUnicodeDefault);
                if(converter) 
                    TECConvertText(converter, 
                                   (ConstTextPtr)source, 
                                   sourceLen, 
                                   &lengthRead, 
                                   (TextPtr)&buf[0], 
                                   size, 
                                   &lengthReturned);
                
            }
            
            str = [[NSString alloc]initWithBytes:(const void *)&buf[0] length:size encoding:NSUnicodeStringEncoding];
            
            if(str)
            {
                uint32_t size = ([str length] * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
                std::vector<uint8_t> buf(size);
                
                if([str getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
                {
                    Param2.setUTF16String((const PA_Unichar *)&buf[0], [str length]);
                }else{
                    returnValue.setIntValue(ERR_CONVERSION_FAILED);                    
                }
                
                [str release];
            }
            
        }
        
    }
    
#else
    
    LPSTR mstr;	 
    UINT ulen, len, mlen;
    DWORD codepage = Param3.getIntValue();
    DWORD mode = 0;
    
    mstr = (LPSTR)Param1.getBytesPtr();	 
    mlen = Param1.getBytesLength();
    
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {				
        mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, NULL, &ulen);
        len = ((ulen * 2) + 2);
        std::vector<uint8_t> buf(len);
        HRESULT result = mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, (WCHAR *)&buf[0], &ulen);
        
        switch(result){
            case E_FAIL:
                returnValue.setIntValue(ERR_CONVERSION_FAILED); 
                break;
            case S_FALSE:
                returnValue.setIntValue(ERR_INVALID_ENCODING); 
                break;            
            case S_OK:
                Param2.setUTF16String((const PA_Unichar *)&buf[0], ulen);
                break;        
        } 
        
        mlang->Release();
    }			
    
#endif

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void CP_Get_good_encodings(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	ARRAY_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
    Param2.setSize(1);
    
    char *data = (char *)Param1.getBytesPtr();
    size_t size = Param1.getBytesLength();
    
#if VERSIONWIN
    
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    
    if(mlang)
    {
		int scores = CP_CODES.getSize();
		std::vector<DetectEncodingInfo> encodings(scores);
        mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, data, (INT *)&size, &encodings[0], &scores);
        
        //no HRESULT?
        for(int i = 0; i < scores ; ++i)
        {
            if(encodings[i].nLangID != 0)
            {
                Param2.appendIntValue(encodings[i].nCodePage); 
            }
        }        

        mlang->Release();
    }
#else
        
    ItemCount count, num;
    
    if(!TECCountAvailableTextEncodings(&count))
    {
        std::vector<TextEncoding> _encodings(count);
        TextEncoding *encodings = &_encodings[0];
        
        TECGetAvailableTextEncodings(encodings, count, &num);
        
        int len = MAX_LENGTH_FOR_ENCODING_NAME;
        
        TECSnifferObjectRef sniffer;
        
        if(!TECCreateSniffer(&sniffer, encodings, num))
        {
            ItemCount numTextEncodings = num;
            ItemCount maxErrs = size;
            ItemCount maxFeatures = size;
            
            std::vector<ItemCount> _numErrsArray(count);
            ItemCount *numErrsArray = &_numErrsArray[0];
            
            std::vector<ItemCount> _numFeaturesArray(count);
            ItemCount *numFeaturesArray = &_numFeaturesArray[0];
            
            OSStatus status = TECSniffTextEncoding(sniffer, 
                                                   (ConstTextPtr)data, 
                                                   (ByteCount)size, 
                                                   encodings, 
                                                   numTextEncodings,  
                                                   numErrsArray, 
                                                   maxErrs, 
                                                   numFeaturesArray,
                                                   maxFeatures);
            
            if(status){
                returnValue.setIntValue(ERR_DETECTION_FAILED); 
            }else{
            
                RegionCode actualRegion;
                TextEncoding actualEncoding;
                ByteCount length;
                
                TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault, 
                                                          kTextEncodingDefaultVariant, 
                                                          kUnicode16BitFormat);
                
                for(unsigned int i = 0; i < numTextEncodings; ++i)
                {
                    PA_YieldAbsolute();
                    
                    if(numErrsArray[i]){
                        break;
                    }else{
                        std::vector<char> buf(len);
                        
                        if(!GetTextEncodingName(
                                                encodings[i], 
                                                kTextEncodingFullName, 
                                                0, 
                                                unicode, 
                                                len, 
                                                &length, 
                                                &actualRegion, 
                                                &actualEncoding, 
                                                (TextPtr)&buf[0]))
                        {
                            CFStringRef name = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar*)&buf[0], (length/2));
                            if(name)
                            {
                                int codepage = TextEncodingNameToWindowsCodepage(name);
                                if(codepage > 0){
                                    Param2.appendIntValue(codepage);
                                }
                                CFRelease(name);								
                            }
                            
                        }
                        
                    }
  
                }
            
            }
  							            
        }
        
    }	
    
#endif	    
    
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

